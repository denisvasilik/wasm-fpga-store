#pylint: disable=C0103
#pylint: disable=C0301
#pylint: disable=C0302
#pylint: disable=W0611
"""
The following pylint warning were disabled:
C0103 Used when a name doesn't doesn't fit the naming convention associated to its type (constant, variable, class...).
C0301 line-too-long
C0302 too-many-lines
W0611 unused-import
"""
"""
This file is automatically generated from HxS.
Do not change something here.
"""

from hxs_core.support import textToOneLine
from hxs_core.support import toAreaInBrackets
from hxs_core.unit import Unit
from hxs_core.block import Block
from hxs_core.fields import FieldDiscretePositions
from hxs_core.fields import FieldAreaDelegated
from hxs_core.fields import FieldAreaExplicit
from hxs_core.fields import FieldAreaExplicitCell
from hxs_core.bit_fields import BitFieldData
from hxs_core.bit_fields import BitFieldEnum
from hxs_core.bit_fields import BitFieldPhysical
from hxs_core.hxs_values import HxsDataValue
from hxs_core.hxs_values import HxsEnumValue
from hxs_core.hxs_values import HxsPhysicalValue



class BitFieldEnumOperation(BitFieldEnum):
    '''
    Description: ,
    Reset value: 0,
    ResetsAffecting: Pwr(X),
    BitFieldEnum, RW_WReg_RLoopBack
    '''

    def __init__(self, parentField, bitNumLowest, bitNumSize, bitFieldAccessType, instanceName):
        super(BitFieldEnumOperation, self).__init__(parentField, bitNumLowest, bitNumSize, bitFieldAccessType, instanceName)
        self.mapValueToEnumName[0b0] = ("Read", "Use ModuleInstanceUID, SectionUID and Idx to read address from store")
        self.mapValueToEnumName[0b1] = ("Write", "Write ModuleInstanceUID, SectionUID and Idx to store")


    @property
    def value(self):
        '''
        Description: ,
        Reset value: 0,
        ResetsAffecting: Pwr(X),
        BitFieldEnum, RW_WReg_RLoopBack
        '''
        rVal = (self.parentField.value >> self.bitNumLowest) & ((1 << self.bitNumSize) -1)
        rHxsVal = HxsEnumValue(rVal, self.bitNumSize, self.mapValueToEnumName.get(rVal, '-'))
        self.tracer.trace(rHxsVal, accessType='r')
        return rVal

    @value.setter
    def value(self, value):
        '''
        Description: ,
        Reset value: 0,
        ResetsAffecting: Pwr(X),
        BitFieldEnum, RW_WReg_RLoopBack
        '''
        if self.parentField.width == self.bitNumSize or self.parentField.hasOverlaidRead:
            wVal = value
        else:
            wVal = (self.parentField.value & ~(((1 << self.bitNumSize) -1) << self.bitNumLowest)) | (value << self.bitNumLowest)
        self.parentField.value = wVal
        wHxsVal = HxsEnumValue(wVal, self.bitNumSize, self.mapValueToEnumName.get(wVal, '-'))
        self.tracer.trace(wHxsVal, accessType='w')

    def is_Read(self):
        '''
        Check if value Read is present,
        Use ModuleInstanceUID, SectionUID and Idx to read address from store
        Returns: boolean compare result
        '''
        rVal = (self.parentField.value >> self.bitNumLowest) & ((1 << self.bitNumSize) -1)
        rHxsVal = HxsEnumValue(rVal, self.bitNumSize, self.mapValueToEnumName.get(rVal, '-'))
        self.tracer.trace(rHxsVal, accessType='r')
        return rVal == 0b0

    def set_Read(self):
        '''
        Set value Read,
        Use ModuleInstanceUID, SectionUID and Idx to read address from store
        Returns: void
        '''
        if self.parentField.width == self.bitNumSize or self.parentField.hasOverlaidRead:
            wVal = (0b0 << self.bitNumLowest)
        else:
            wVal = (self.parentField.value & ~(((1 << self.bitNumSize) -1) << self.bitNumLowest)) | (0b0 << self.bitNumLowest)
        self.parentField.value = wVal
        wHxsVal = HxsEnumValue(wVal, self.bitNumSize, self.mapValueToEnumName.get(wVal, '-'))
        self.tracer.trace(wHxsVal, accessType='w')

    @property
    def Read(self):
        '''
        Constant equivalent to Read,
        Use ModuleInstanceUID, SectionUID and Idx to read address from store
         Returns: The constant
        '''
        return 0b0

    def is_Write(self):
        '''
        Check if value Write is present,
        Write ModuleInstanceUID, SectionUID and Idx to store
        Returns: boolean compare result
        '''
        rVal = (self.parentField.value >> self.bitNumLowest) & ((1 << self.bitNumSize) -1)
        rHxsVal = HxsEnumValue(rVal, self.bitNumSize, self.mapValueToEnumName.get(rVal, '-'))
        self.tracer.trace(rHxsVal, accessType='r')
        return rVal == 0b1

    def set_Write(self):
        '''
        Set value Write,
        Write ModuleInstanceUID, SectionUID and Idx to store
        Returns: void
        '''
        if self.parentField.width == self.bitNumSize or self.parentField.hasOverlaidRead:
            wVal = (0b1 << self.bitNumLowest)
        else:
            wVal = (self.parentField.value & ~(((1 << self.bitNumSize) -1) << self.bitNumLowest)) | (0b1 << self.bitNumLowest)
        self.parentField.value = wVal
        wHxsVal = HxsEnumValue(wVal, self.bitNumSize, self.mapValueToEnumName.get(wVal, '-'))
        self.tracer.trace(wHxsVal, accessType='w')

    @property
    def Write(self):
        '''
        Constant equivalent to Write,
        Write ModuleInstanceUID, SectionUID and Idx to store
         Returns: The constant
        '''
        return 0b1

    def is_default(self):
        '''
        Check if value default is present
        Returns: boolean compare result
        '''
        rVal = (self.parentField.value >> self.bitNumLowest) & ((1 << self.bitNumSize) -1)
        rHxsVal = HxsEnumValue(rVal, self.bitNumSize, self.mapValueToEnumName.get(rVal, '-'))
        self.tracer.trace(rHxsVal, accessType='r')
        return rVal == 0b0

    def set_default(self):
        if self.parentField.width == self.bitNumSize or self.parentField.hasOverlaidRead:
            wVal = (0b0 << self.bitNumLowest)
        else:
            wVal = (self.parentField.value & ~(((1 << self.bitNumSize) -1) << self.bitNumLowest)) | (0b0 << self.bitNumLowest)
        self.parentField.value = wVal
        wHxsVal = HxsEnumValue(wVal, self.bitNumSize, self.mapValueToEnumName.get(wVal, '-'))
        self.tracer.trace(wHxsVal, accessType='w')

    @property
    def default(self):
        '''
        Constant equivalent to default
        Returns: The constant
        '''
        return 0b0

class BitFieldEnumRun(BitFieldEnum):
    '''
    Description: ,
    Reset value: 0,
    ResetsAffecting: Pwr(X),
    BitFieldEnum, RW_WReg_RLoopBack
    '''

    def __init__(self, parentField, bitNumLowest, bitNumSize, bitFieldAccessType, instanceName):
        super(BitFieldEnumRun, self).__init__(parentField, bitNumLowest, bitNumSize, bitFieldAccessType, instanceName)
        self.mapValueToEnumName[0b0] = ("DoNotRun", "Do not load modules")
        self.mapValueToEnumName[0b1] = ("DoRun", "Load modules")


    @property
    def value(self):
        '''
        Description: ,
        Reset value: 0,
        ResetsAffecting: Pwr(X),
        BitFieldEnum, RW_WReg_RLoopBack
        '''
        rVal = (self.parentField.value >> self.bitNumLowest) & ((1 << self.bitNumSize) -1)
        rHxsVal = HxsEnumValue(rVal, self.bitNumSize, self.mapValueToEnumName.get(rVal, '-'))
        self.tracer.trace(rHxsVal, accessType='r')
        return rVal

    @value.setter
    def value(self, value):
        '''
        Description: ,
        Reset value: 0,
        ResetsAffecting: Pwr(X),
        BitFieldEnum, RW_WReg_RLoopBack
        '''
        if self.parentField.width == self.bitNumSize or self.parentField.hasOverlaidRead:
            wVal = value
        else:
            wVal = (self.parentField.value & ~(((1 << self.bitNumSize) -1) << self.bitNumLowest)) | (value << self.bitNumLowest)
        self.parentField.value = wVal
        wHxsVal = HxsEnumValue(wVal, self.bitNumSize, self.mapValueToEnumName.get(wVal, '-'))
        self.tracer.trace(wHxsVal, accessType='w')

    def is_DoNotRun(self):
        '''
        Check if value DoNotRun is present,
        Do not load modules
        Returns: boolean compare result
        '''
        rVal = (self.parentField.value >> self.bitNumLowest) & ((1 << self.bitNumSize) -1)
        rHxsVal = HxsEnumValue(rVal, self.bitNumSize, self.mapValueToEnumName.get(rVal, '-'))
        self.tracer.trace(rHxsVal, accessType='r')
        return rVal == 0b0

    def set_DoNotRun(self):
        '''
        Set value DoNotRun,
        Do not load modules
        Returns: void
        '''
        if self.parentField.width == self.bitNumSize or self.parentField.hasOverlaidRead:
            wVal = (0b0 << self.bitNumLowest)
        else:
            wVal = (self.parentField.value & ~(((1 << self.bitNumSize) -1) << self.bitNumLowest)) | (0b0 << self.bitNumLowest)
        self.parentField.value = wVal
        wHxsVal = HxsEnumValue(wVal, self.bitNumSize, self.mapValueToEnumName.get(wVal, '-'))
        self.tracer.trace(wHxsVal, accessType='w')

    @property
    def DoNotRun(self):
        '''
        Constant equivalent to DoNotRun,
        Do not load modules
         Returns: The constant
        '''
        return 0b0

    def is_DoRun(self):
        '''
        Check if value DoRun is present,
        Load modules
        Returns: boolean compare result
        '''
        rVal = (self.parentField.value >> self.bitNumLowest) & ((1 << self.bitNumSize) -1)
        rHxsVal = HxsEnumValue(rVal, self.bitNumSize, self.mapValueToEnumName.get(rVal, '-'))
        self.tracer.trace(rHxsVal, accessType='r')
        return rVal == 0b1

    def set_DoRun(self):
        '''
        Set value DoRun,
        Load modules
        Returns: void
        '''
        if self.parentField.width == self.bitNumSize or self.parentField.hasOverlaidRead:
            wVal = (0b1 << self.bitNumLowest)
        else:
            wVal = (self.parentField.value & ~(((1 << self.bitNumSize) -1) << self.bitNumLowest)) | (0b1 << self.bitNumLowest)
        self.parentField.value = wVal
        wHxsVal = HxsEnumValue(wVal, self.bitNumSize, self.mapValueToEnumName.get(wVal, '-'))
        self.tracer.trace(wHxsVal, accessType='w')

    @property
    def DoRun(self):
        '''
        Constant equivalent to DoRun,
        Load modules
         Returns: The constant
        '''
        return 0b1

    def is_default(self):
        '''
        Check if value default is present
        Returns: boolean compare result
        '''
        rVal = (self.parentField.value >> self.bitNumLowest) & ((1 << self.bitNumSize) -1)
        rHxsVal = HxsEnumValue(rVal, self.bitNumSize, self.mapValueToEnumName.get(rVal, '-'))
        self.tracer.trace(rHxsVal, accessType='r')
        return rVal == 0b0

    def set_default(self):
        if self.parentField.width == self.bitNumSize or self.parentField.hasOverlaidRead:
            wVal = (0b0 << self.bitNumLowest)
        else:
            wVal = (self.parentField.value & ~(((1 << self.bitNumSize) -1) << self.bitNumLowest)) | (0b0 << self.bitNumLowest)
        self.parentField.value = wVal
        wHxsVal = HxsEnumValue(wVal, self.bitNumSize, self.mapValueToEnumName.get(wVal, '-'))
        self.tracer.trace(wHxsVal, accessType='w')

    @property
    def default(self):
        '''
        Constant equivalent to default
        Returns: The constant
        '''
        return 0b0



class BitFieldEnumBusy(BitFieldEnum):
    '''
    Description: ,
    Reset value: 0,
    ResetsAffecting: Pwr(X),
    BitFieldEnum, R_RTrans
    '''

    def __init__(self, parentField, bitNumLowest, bitNumSize, bitFieldAccessType, instanceName):
        super(BitFieldEnumBusy, self).__init__(parentField, bitNumLowest, bitNumSize, bitFieldAccessType, instanceName)
        self.mapValueToEnumName[0b0] = ("IsNotBusy", "Module loader is idle.")
        self.mapValueToEnumName[0b1] = ("IsBusy", "Module loader is busy.")


    @property
    def value(self):
        '''
        Description: ,
        Reset value: 0,
        ResetsAffecting: Pwr(X),
        BitFieldEnum, R_RTrans
        '''
        rVal = (self.parentField.value >> self.bitNumLowest) & ((1 << self.bitNumSize) -1)
        rHxsVal = HxsEnumValue(rVal, self.bitNumSize, self.mapValueToEnumName.get(rVal, '-'))
        self.tracer.trace(rHxsVal, accessType='r')
        return rVal

    @value.setter
    def value(self):
        '''
        Description: ,
        Reset value: 0,
        ResetsAffecting: Pwr(X),
        BitFieldEnum, R_RTrans
        '''
        raise AttributeError(self.__class__.__name__ + ' is read only')

    def is_IsNotBusy(self):
        '''
        Check if value IsNotBusy is present,
        Module loader is idle.
        Returns: boolean compare result
        '''
        rVal = (self.parentField.value >> self.bitNumLowest) & ((1 << self.bitNumSize) -1)
        rHxsVal = HxsEnumValue(rVal, self.bitNumSize, self.mapValueToEnumName.get(rVal, '-'))
        self.tracer.trace(rHxsVal, accessType='r')
        return rVal == 0b0

    @property
    def IsNotBusy(self):
        '''
        Constant equivalent to IsNotBusy,
        Module loader is idle.
         Returns: The constant
        '''
        return 0b0

    def is_IsBusy(self):
        '''
        Check if value IsBusy is present,
        Module loader is busy.
        Returns: boolean compare result
        '''
        rVal = (self.parentField.value >> self.bitNumLowest) & ((1 << self.bitNumSize) -1)
        rHxsVal = HxsEnumValue(rVal, self.bitNumSize, self.mapValueToEnumName.get(rVal, '-'))
        self.tracer.trace(rHxsVal, accessType='r')
        return rVal == 0b1

    @property
    def IsBusy(self):
        '''
        Constant equivalent to IsBusy,
        Module loader is busy.
         Returns: The constant
        '''
        return 0b1

    def is_default(self):
        '''
        Check if value default is present
        Returns: boolean compare result
        '''
        rVal = (self.parentField.value >> self.bitNumLowest) & ((1 << self.bitNumSize) -1)
        rHxsVal = HxsEnumValue(rVal, self.bitNumSize, self.mapValueToEnumName.get(rVal, '-'))
        self.tracer.trace(rHxsVal, accessType='r')
        return rVal == 0b0

    @property
    def default(self):
        '''
        Constant equivalent to default
        Returns: The constant
        '''
        return 0b0



class BitFieldDataModuleInstanceUID(BitFieldData):
    '''
    Description: ,
    Reset value: 0,
    ResetsAffecting: Pwr(X),
    BitFieldData, RW_WReg_RLoopBack
    '''

    def __init__(self, parentField, bitNumLowest, bitNumSize, bitFieldAccessType, instanceName):
        super(BitFieldDataModuleInstanceUID, self).__init__(parentField, bitNumLowest, bitNumSize, bitFieldAccessType, instanceName)


    @property
    def value(self):
        '''
        Description: ,
        Reset value: 0,
        ResetsAffecting: Pwr(X),
        BitFieldData, RW_WReg_RLoopBack
        '''
        rVal = (self.parentField.value >> self.bitNumLowest) & ((1 << self.bitNumSize) -1)
        rHxsVal = HxsDataValue(rVal, self.bitNumSize)
        self.tracer.trace(rHxsVal, accessType='r')
        return rVal

    @value.setter
    def value(self, value):
        '''
        Description: 
        Reset value: 0,
        ResetsAffecting: Pwr(X),
        BitFieldData, RW_WReg_RLoopBack
        '''
        if self.parentField.width == self.bitNumSize or self.parentField.hasOverlaidRead:
            wVal = value
        else:
            wVal = (self.parentField.value & ~(((1 << self.bitNumSize) -1) << self.bitNumLowest)) | (value << self.bitNumLowest)
        self.parentField.value = wVal
        wHxsVal = HxsDataValue(wVal, self.bitNumSize)
        self.tracer.trace(wHxsVal, accessType='w')


    def is_default(self):
        '''
        Check if value default is present
        Returns: boolean compare result
        '''
        rVal = (self.parentField.value >> self.bitNumLowest) & ((1 << self.bitNumSize) -1)
        rHxsVal = HxsDataValue(rVal, self.bitNumSize)
        self.tracer.trace(rHxsVal, accessType='r')
        return rVal == 0b0

    def set_default(self):
        if self.parentField.width == self.bitNumSize or self.parentField.hasOverlaidRead:
            wVal = (0b0 << self.bitNumLowest)
        else:
            wVal = (self.parentField.value & ~(((1 << self.bitNumSize) -1) << self.bitNumLowest)) | (0b0 << self.bitNumLowest)
        self.parentField.value = wVal
        wHxsVal = HxsDataValue(wVal, self.bitNumSize)
        self.tracer.trace(wHxsVal, accessType='w')

    @property
    def default(self):
        '''
        Constant equivalent to default
        Returns: The constant
        '''
        return 0b0



class BitFieldDataSectionUID(BitFieldData):
    '''
    Description: ,
    Reset value: 0,
    ResetsAffecting: Pwr(X),
    BitFieldData, RW_WReg_RLoopBack
    '''

    def __init__(self, parentField, bitNumLowest, bitNumSize, bitFieldAccessType, instanceName):
        super(BitFieldDataSectionUID, self).__init__(parentField, bitNumLowest, bitNumSize, bitFieldAccessType, instanceName)


    @property
    def value(self):
        '''
        Description: ,
        Reset value: 0,
        ResetsAffecting: Pwr(X),
        BitFieldData, RW_WReg_RLoopBack
        '''
        rVal = (self.parentField.value >> self.bitNumLowest) & ((1 << self.bitNumSize) -1)
        rHxsVal = HxsDataValue(rVal, self.bitNumSize)
        self.tracer.trace(rHxsVal, accessType='r')
        return rVal

    @value.setter
    def value(self, value):
        '''
        Description: 
        Reset value: 0,
        ResetsAffecting: Pwr(X),
        BitFieldData, RW_WReg_RLoopBack
        '''
        if self.parentField.width == self.bitNumSize or self.parentField.hasOverlaidRead:
            wVal = value
        else:
            wVal = (self.parentField.value & ~(((1 << self.bitNumSize) -1) << self.bitNumLowest)) | (value << self.bitNumLowest)
        self.parentField.value = wVal
        wHxsVal = HxsDataValue(wVal, self.bitNumSize)
        self.tracer.trace(wHxsVal, accessType='w')


    def is_default(self):
        '''
        Check if value default is present
        Returns: boolean compare result
        '''
        rVal = (self.parentField.value >> self.bitNumLowest) & ((1 << self.bitNumSize) -1)
        rHxsVal = HxsDataValue(rVal, self.bitNumSize)
        self.tracer.trace(rHxsVal, accessType='r')
        return rVal == 0b0

    def set_default(self):
        if self.parentField.width == self.bitNumSize or self.parentField.hasOverlaidRead:
            wVal = (0b0 << self.bitNumLowest)
        else:
            wVal = (self.parentField.value & ~(((1 << self.bitNumSize) -1) << self.bitNumLowest)) | (0b0 << self.bitNumLowest)
        self.parentField.value = wVal
        wHxsVal = HxsDataValue(wVal, self.bitNumSize)
        self.tracer.trace(wHxsVal, accessType='w')

    @property
    def default(self):
        '''
        Constant equivalent to default
        Returns: The constant
        '''
        return 0b0



class BitFieldDataIdx(BitFieldData):
    '''
    Description: ,
    Reset value: 0,
    ResetsAffecting: Pwr(X),
    BitFieldData, RW_WReg_RLoopBack
    '''

    def __init__(self, parentField, bitNumLowest, bitNumSize, bitFieldAccessType, instanceName):
        super(BitFieldDataIdx, self).__init__(parentField, bitNumLowest, bitNumSize, bitFieldAccessType, instanceName)


    @property
    def value(self):
        '''
        Description: ,
        Reset value: 0,
        ResetsAffecting: Pwr(X),
        BitFieldData, RW_WReg_RLoopBack
        '''
        rVal = (self.parentField.value >> self.bitNumLowest) & ((1 << self.bitNumSize) -1)
        rHxsVal = HxsDataValue(rVal, self.bitNumSize)
        self.tracer.trace(rHxsVal, accessType='r')
        return rVal

    @value.setter
    def value(self, value):
        '''
        Description: 
        Reset value: 0,
        ResetsAffecting: Pwr(X),
        BitFieldData, RW_WReg_RLoopBack
        '''
        if self.parentField.width == self.bitNumSize or self.parentField.hasOverlaidRead:
            wVal = value
        else:
            wVal = (self.parentField.value & ~(((1 << self.bitNumSize) -1) << self.bitNumLowest)) | (value << self.bitNumLowest)
        self.parentField.value = wVal
        wHxsVal = HxsDataValue(wVal, self.bitNumSize)
        self.tracer.trace(wHxsVal, accessType='w')


    def is_default(self):
        '''
        Check if value default is present
        Returns: boolean compare result
        '''
        rVal = (self.parentField.value >> self.bitNumLowest) & ((1 << self.bitNumSize) -1)
        rHxsVal = HxsDataValue(rVal, self.bitNumSize)
        self.tracer.trace(rHxsVal, accessType='r')
        return rVal == 0b0

    def set_default(self):
        if self.parentField.width == self.bitNumSize or self.parentField.hasOverlaidRead:
            wVal = (0b0 << self.bitNumLowest)
        else:
            wVal = (self.parentField.value & ~(((1 << self.bitNumSize) -1) << self.bitNumLowest)) | (0b0 << self.bitNumLowest)
        self.parentField.value = wVal
        wHxsVal = HxsDataValue(wVal, self.bitNumSize)
        self.tracer.trace(wHxsVal, accessType='w')

    @property
    def default(self):
        '''
        Constant equivalent to default
        Returns: The constant
        '''
        return 0b0



class BitFieldDataAddress(BitFieldData):
    '''
    Description: ,
    Reset value: 0,
    ResetsAffecting: Pwr(X),
    BitFieldData, R_RTrans
    '''

    def __init__(self, parentField, bitNumLowest, bitNumSize, bitFieldAccessType, instanceName):
        super(BitFieldDataAddress, self).__init__(parentField, bitNumLowest, bitNumSize, bitFieldAccessType, instanceName)


    @property
    def value(self):
        '''
        Description: ,
        Reset value: 0,
        ResetsAffecting: Pwr(X),
        BitFieldData, R_RTrans
        '''
        rVal = (self.parentField.value >> self.bitNumLowest) & ((1 << self.bitNumSize) -1)
        rHxsVal = HxsDataValue(rVal, self.bitNumSize)
        self.tracer.trace(rHxsVal, accessType='r')
        return rVal

    @value.setter
    def value(self):
        '''
        Description: ,
        Reset value: 0,
        ResetsAffecting: Pwr(X),
        BitFieldData, R_RTrans
        '''
        raise AttributeError(self.__class__.__name__ + ' is read only')

    def is_default(self):
        '''
        Check if value default is present
        Returns: boolean compare result
        '''
        rVal = (self.parentField.value >> self.bitNumLowest) & ((1 << self.bitNumSize) -1)
        rHxsVal = HxsDataValue(rVal, self.bitNumSize)
        self.tracer.trace(rHxsVal, accessType='r')
        return rVal == 0b0

    @property
    def default(self):
        '''
        Constant equivalent to default
        Returns: The constant
        '''
        return 0b0


class FieldDiscretePositionsControlReg(FieldDiscretePositions):
    '''
    Name: Control Register (32bit),
    Description: ,
    FieldDiscretePositions
    '''

    def __init__(self, parentBlock, width, addressOffset, instanceName, isAffectedByRead=False, hasOverlaidRead=False):
        super(FieldDiscretePositionsControlReg, self).__init__(parentBlock, width, addressOffset, instanceName, isAffectedByRead=isAffectedByRead, hasOverlaidRead=hasOverlaidRead)
        self._enm_Operation = BitFieldEnumOperation(self, 1, 1, 'RW_WReg_RLoopBack', 'enm_Operation')
        self.bitFields.append(self._enm_Operation)
        self._enm_Run = BitFieldEnumRun(self, 0, 1, 'RW_WReg_RLoopBack', 'enm_Run')
        self.bitFields.append(self._enm_Run)

    @property
    def value(self):
        '''
        Name: Control Register (32bit),
        Description: ,
        FieldDiscretePositions
        '''
        rVal = self.busAccess.read_from_bus(self.width, self.busSegment, self.addressOffset + self.busBaseAddress)
        self.tracer.trace(rVal, accessType='r')
        return rVal

    @value.setter
    def value(self, value):
        '''
        Name: Control Register (32bit),
        Description: ,
        FieldDiscretePositions
        '''
        self.tracer.trace(value, accessType='w')
        self.busAccess.write_to_bus(self.width, self.busSegment, self.addressOffset + self.busBaseAddress, value)

    @property
    def enm_Operation(self):
        '''
        Description: 
        Reset value: 0
        ResetsAffecting: Pwr(X)
        BitFieldEnum, RW_WReg_RLoopBack
        '''
        return self._enm_Operation

    @property
    def enm_Run(self):
        '''
        Description: 
        Reset value: 0
        ResetsAffecting: Pwr(X)
        BitFieldEnum, RW_WReg_RLoopBack
        '''
        return self._enm_Run


class FieldDiscretePositionsStatusReg(FieldDiscretePositions):
    '''
    Name: Status Register (32bit),
    Description: ,
    FieldDiscretePositions
    '''

    def __init__(self, parentBlock, width, addressOffset, instanceName, isAffectedByRead=False, hasOverlaidRead=False):
        super(FieldDiscretePositionsStatusReg, self).__init__(parentBlock, width, addressOffset, instanceName, isAffectedByRead=isAffectedByRead, hasOverlaidRead=hasOverlaidRead)
        self._enm_Busy = BitFieldEnumBusy(self, 0, 1, 'R_RTrans', 'enm_Busy')
        self.bitFields.append(self._enm_Busy)

    @property
    def value(self):
        '''
        Name: Status Register (32bit),
        Description: ,
        FieldDiscretePositions
        '''
        rVal = self.busAccess.read_from_bus(self.width, self.busSegment, self.addressOffset + self.busBaseAddress)
        self.tracer.trace(rVal, accessType='r')
        return rVal

    @value.setter
    def value(self, value):
        '''
        Name: Status Register (32bit),
        Description: ,
        FieldDiscretePositions
        '''
        self.tracer.trace(value, accessType='w')
        self.busAccess.write_to_bus(self.width, self.busSegment, self.addressOffset + self.busBaseAddress, value)

    @property
    def enm_Busy(self):
        '''
        Description: 
        Reset value: 0
        ResetsAffecting: Pwr(X)
        BitFieldEnum, R_RTrans
        '''
        return self._enm_Busy


class FieldDiscretePositionsModuleInstanceUidReg(FieldDiscretePositions):
    '''
    Name: Module Instance UID Register (32bit),
    Description: ,
    FieldDiscretePositions
    '''

    def __init__(self, parentBlock, width, addressOffset, instanceName, isAffectedByRead=False, hasOverlaidRead=False):
        super(FieldDiscretePositionsModuleInstanceUidReg, self).__init__(parentBlock, width, addressOffset, instanceName, isAffectedByRead=isAffectedByRead, hasOverlaidRead=hasOverlaidRead)
        self._dat_ModuleInstanceUID = BitFieldDataModuleInstanceUID(self, 0, 32, 'RW_WReg_RLoopBack', 'dat_ModuleInstanceUID')
        self.bitFields.append(self._dat_ModuleInstanceUID)

    @property
    def value(self):
        '''
        Name: Module Instance UID Register (32bit),
        Description: ,
        FieldDiscretePositions
        '''
        rVal = self.busAccess.read_from_bus(self.width, self.busSegment, self.addressOffset + self.busBaseAddress)
        self.tracer.trace(rVal, accessType='r')
        return rVal

    @value.setter
    def value(self, value):
        '''
        Name: Module Instance UID Register (32bit),
        Description: ,
        FieldDiscretePositions
        '''
        self.tracer.trace(value, accessType='w')
        self.busAccess.write_to_bus(self.width, self.busSegment, self.addressOffset + self.busBaseAddress, value)

    @property
    def dat_ModuleInstanceUID(self):
        '''
        Description: 
        Reset value: 0
        ResetsAffecting: Pwr(X)
        BitFieldData, RW_WReg_RLoopBack
        '''
        return self._dat_ModuleInstanceUID


class FieldDiscretePositionsSectionUidReg(FieldDiscretePositions):
    '''
    Name: Section Instance UID Register (32bit),
    Description: ,
    FieldDiscretePositions
    '''

    def __init__(self, parentBlock, width, addressOffset, instanceName, isAffectedByRead=False, hasOverlaidRead=False):
        super(FieldDiscretePositionsSectionUidReg, self).__init__(parentBlock, width, addressOffset, instanceName, isAffectedByRead=isAffectedByRead, hasOverlaidRead=hasOverlaidRead)
        self._dat_SectionUID = BitFieldDataSectionUID(self, 0, 32, 'RW_WReg_RLoopBack', 'dat_SectionUID')
        self.bitFields.append(self._dat_SectionUID)

    @property
    def value(self):
        '''
        Name: Section Instance UID Register (32bit),
        Description: ,
        FieldDiscretePositions
        '''
        rVal = self.busAccess.read_from_bus(self.width, self.busSegment, self.addressOffset + self.busBaseAddress)
        self.tracer.trace(rVal, accessType='r')
        return rVal

    @value.setter
    def value(self, value):
        '''
        Name: Section Instance UID Register (32bit),
        Description: ,
        FieldDiscretePositions
        '''
        self.tracer.trace(value, accessType='w')
        self.busAccess.write_to_bus(self.width, self.busSegment, self.addressOffset + self.busBaseAddress, value)

    @property
    def dat_SectionUID(self):
        '''
        Description: 
        Reset value: 0
        ResetsAffecting: Pwr(X)
        BitFieldData, RW_WReg_RLoopBack
        '''
        return self._dat_SectionUID


class FieldDiscretePositionsIdxReg(FieldDiscretePositions):
    '''
    Name: Module Section Idx Register (32bit),
    Description: ,
    FieldDiscretePositions
    '''

    def __init__(self, parentBlock, width, addressOffset, instanceName, isAffectedByRead=False, hasOverlaidRead=False):
        super(FieldDiscretePositionsIdxReg, self).__init__(parentBlock, width, addressOffset, instanceName, isAffectedByRead=isAffectedByRead, hasOverlaidRead=hasOverlaidRead)
        self._dat_Idx = BitFieldDataIdx(self, 0, 32, 'RW_WReg_RLoopBack', 'dat_Idx')
        self.bitFields.append(self._dat_Idx)

    @property
    def value(self):
        '''
        Name: Module Section Idx Register (32bit),
        Description: ,
        FieldDiscretePositions
        '''
        rVal = self.busAccess.read_from_bus(self.width, self.busSegment, self.addressOffset + self.busBaseAddress)
        self.tracer.trace(rVal, accessType='r')
        return rVal

    @value.setter
    def value(self, value):
        '''
        Name: Module Section Idx Register (32bit),
        Description: ,
        FieldDiscretePositions
        '''
        self.tracer.trace(value, accessType='w')
        self.busAccess.write_to_bus(self.width, self.busSegment, self.addressOffset + self.busBaseAddress, value)

    @property
    def dat_Idx(self):
        '''
        Description: 
        Reset value: 0
        ResetsAffecting: Pwr(X)
        BitFieldData, RW_WReg_RLoopBack
        '''
        return self._dat_Idx


class FieldDiscretePositionsAddressReg(FieldDiscretePositions):
    '''
    Name: Module Address Register (32bit),
    Description: ,
    FieldDiscretePositions
    '''

    def __init__(self, parentBlock, width, addressOffset, instanceName, isAffectedByRead=False, hasOverlaidRead=False):
        super(FieldDiscretePositionsAddressReg, self).__init__(parentBlock, width, addressOffset, instanceName, isAffectedByRead=isAffectedByRead, hasOverlaidRead=hasOverlaidRead)
        self._dat_Address = BitFieldDataAddress(self, 0, 32, 'R_RTrans', 'dat_Address')
        self.bitFields.append(self._dat_Address)

    @property
    def value(self):
        '''
        Name: Module Address Register (32bit),
        Description: ,
        FieldDiscretePositions
        '''
        rVal = self.busAccess.read_from_bus(self.width, self.busSegment, self.addressOffset + self.busBaseAddress)
        self.tracer.trace(rVal, accessType='r')
        return rVal

    @value.setter
    def value(self, value):
        '''
        Name: Module Address Register (32bit),
        Description: ,
        FieldDiscretePositions
        '''
        self.tracer.trace(value, accessType='w')
        self.busAccess.write_to_bus(self.width, self.busSegment, self.addressOffset + self.busBaseAddress, value)

    @property
    def dat_Address(self):
        '''
        Description: 
        Reset value: 0
        ResetsAffecting: Pwr(X)
        BitFieldData, R_RTrans
        '''
        return self._dat_Address

class BlockStoreBlk(Block):
    '''
    Name:  WebAssembly Store Block
    Description: This block describes the WebAssembly store block.
    Bus Description: 
    Bus Segment: 0
    Block Resets:
    Pwr, Power On Reset
    '''

    def __init__(self, parentUnit, busAccess, busSegment, busBaseAddress, size, instanceName):
        super(BlockStoreBlk, self).__init__(parentUnit, busAccess, busSegment, busBaseAddress, size, instanceName)
        self._reg_ControlReg = FieldDiscretePositionsControlReg(self, 32, 0x000000, 'reg_ControlReg', isAffectedByRead=False, hasOverlaidRead=False)
        self.fields.append(self._reg_ControlReg)
        self._reg_StatusReg = FieldDiscretePositionsStatusReg(self, 32, 0x000004, 'reg_StatusReg', isAffectedByRead=False, hasOverlaidRead=False)
        self.fields.append(self._reg_StatusReg)
        self._reg_ModuleInstanceUidReg = FieldDiscretePositionsModuleInstanceUidReg(self, 32, 0x000008, 'reg_ModuleInstanceUidReg', isAffectedByRead=False, hasOverlaidRead=False)
        self.fields.append(self._reg_ModuleInstanceUidReg)
        self._reg_SectionUidReg = FieldDiscretePositionsSectionUidReg(self, 32, 0x00000C, 'reg_SectionUidReg', isAffectedByRead=False, hasOverlaidRead=False)
        self.fields.append(self._reg_SectionUidReg)
        self._reg_IdxReg = FieldDiscretePositionsIdxReg(self, 32, 0x000010, 'reg_IdxReg', isAffectedByRead=False, hasOverlaidRead=False)
        self.fields.append(self._reg_IdxReg)
        self._reg_AddressReg = FieldDiscretePositionsAddressReg(self, 32, 0x000014, 'reg_AddressReg', isAffectedByRead=False, hasOverlaidRead=False)
        self.fields.append(self._reg_AddressReg)

    @property
    def reg_ControlReg(self):
        ''' FieldDiscretePositions, Control Register
        Description: 
        '''
        return self._reg_ControlReg

    @property
    def reg_StatusReg(self):
        ''' FieldDiscretePositions, Status Register
        Description: 
        '''
        return self._reg_StatusReg

    @property
    def reg_ModuleInstanceUidReg(self):
        ''' FieldDiscretePositions, Module Instance UID Register
        Description: 
        '''
        return self._reg_ModuleInstanceUidReg

    @property
    def reg_SectionUidReg(self):
        ''' FieldDiscretePositions, Section Instance UID Register
        Description: 
        '''
        return self._reg_SectionUidReg

    @property
    def reg_IdxReg(self):
        ''' FieldDiscretePositions, Module Section Idx Register
        Description: 
        '''
        return self._reg_IdxReg

    @property
    def reg_AddressReg(self):
        ''' FieldDiscretePositions, Module Address Register
        Description: 
        '''
        return self._reg_AddressReg
